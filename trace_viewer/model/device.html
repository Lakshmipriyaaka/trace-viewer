<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/base/guid.html">
<link rel="import" href="/base/range.html">
<link rel="import" href="/model/event_container.html">

<script>
'use strict';

/**
 * @fileoverview Provides the Device class.
 */
tr.exportTo('tr.model', function() {

  /**
   * Device represents the device-level objects in the model.
   * @constructor
     @extends {tr.model.EventContainer}
   */
  function Device(model) {
    if (!model)
      throw new Error('Must provide a model.');

    tr.model.EventContainer.call(this);

    this.bounds = new tr.b.Range();
    this.counters = {};
    this.guid = tr.b.GUID.allocate();
  };

  Device.compare = function(x, y) {
    return x.guid - y.guid;
  };

  Device.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    compareTo: function(that) {
      return Device.compare(this, that);
    },

    get userFriendlyName() {
      return 'Device';
    },

    get userFriendlyDetails() {
      return 'Device';
    },

    get stableId() {
      return 'Device';
    },

    getSettingsKey: function() {
      return 'device';
    },

    updateBounds: function() {
      this.bounds.reset();
      // TODO(charliea): Update and add bounds for all children counters
    },

    shiftTimestampsForward: function(amount) {
      // TODO(charliea): Shift timestamps for all children
    },

    addCategoriesToDict: function(categoriesDict) {
      for (var id in this.counters)
        categoriesDict[this.counters[id].category] = true
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
      for (var id in this.counters)
        callback.call(opt_this, this.threads[id]);
    },

    // TODO(charliea): This method differs from every other type that allows
    // counters, which is definitely a code smell. However, we need some way
    // to specify the type of counter to add.
    /**
     * Adds the specified counter to the device.
     */
    addCounter: function(counter) {
      if (this.counters[counter.id]) {
        throw new Error('Counter with the same ID already exists.');
      }
      this.counters[counter.id] = counter;
    },

    /**
     * Returns the counter with the specified ID.
     */
    getCounter: function(id) {
      return this.counters[id];
    }

  };

  return {
    Device: Device
  };
});
</script>
